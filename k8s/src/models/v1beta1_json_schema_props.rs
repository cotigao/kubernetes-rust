/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.12.3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// V1beta1JsonSchemaProps : JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct V1beta1JsonSchemaProps {
  #[serde(rename = "$ref")]
  _ref: Option<String>,
  #[serde(rename = "$schema")]
  schema: Option<String>,
  /// JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
  #[serde(rename = "additionalItems")]
  additional_items: Option<::serde_json::Value>,
  /// JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
  #[serde(rename = "additionalProperties")]
  additional_properties: Option<::serde_json::Value>,
  #[serde(rename = "allOf")]
  all_of: Option<Vec<::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "anyOf")]
  any_of: Option<Vec<::models::V1beta1JsonSchemaProps>>,
  /// JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
  #[serde(rename = "default")]
  default: Option<::serde_json::Value>,
  #[serde(rename = "definitions")]
  definitions: Option<::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "dependencies")]
  dependencies: Option<::std::collections::HashMap<String, ::serde_json::Value>>,
  #[serde(rename = "description")]
  description: Option<String>,
  #[serde(rename = "enum")]
  _enum: Option<Vec<::serde_json::Value>>,
  /// JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
  #[serde(rename = "example")]
  example: Option<::serde_json::Value>,
  #[serde(rename = "exclusiveMaximum")]
  exclusive_maximum: Option<bool>,
  #[serde(rename = "exclusiveMinimum")]
  exclusive_minimum: Option<bool>,
  #[serde(rename = "externalDocs")]
  external_docs: Option<::models::V1beta1ExternalDocumentation>,
  #[serde(rename = "format")]
  format: Option<String>,
  #[serde(rename = "id")]
  id: Option<String>,
  /// JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes.
  #[serde(rename = "items")]
  items: Option<::serde_json::Value>,
  #[serde(rename = "maxItems")]
  max_items: Option<i64>,
  #[serde(rename = "maxLength")]
  max_length: Option<i64>,
  #[serde(rename = "maxProperties")]
  max_properties: Option<i64>,
  #[serde(rename = "maximum")]
  maximum: Option<f64>,
  #[serde(rename = "minItems")]
  min_items: Option<i64>,
  #[serde(rename = "minLength")]
  min_length: Option<i64>,
  #[serde(rename = "minProperties")]
  min_properties: Option<i64>,
  #[serde(rename = "minimum")]
  minimum: Option<f64>,
  #[serde(rename = "multipleOf")]
  multiple_of: Option<f64>,
  #[serde(rename = "not")]
  not: Option<Box<::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "oneOf")]
  one_of: Option<Vec<::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "pattern")]
  pattern: Option<String>,
  #[serde(rename = "patternProperties")]
  pattern_properties: Option<::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "properties")]
  properties: Option<::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>>,
  #[serde(rename = "required")]
  required: Option<Vec<String>>,
  #[serde(rename = "title")]
  title: Option<String>,
  #[serde(rename = "type")]
  _type: Option<String>,
  #[serde(rename = "uniqueItems")]
  unique_items: Option<bool>
}

impl V1beta1JsonSchemaProps {
  /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
  pub fn new() -> V1beta1JsonSchemaProps {
    V1beta1JsonSchemaProps {
      _ref: None,
      schema: None,
      additional_items: None,
      additional_properties: None,
      all_of: None,
      any_of: None,
      default: None,
      definitions: None,
      dependencies: None,
      description: None,
      _enum: None,
      example: None,
      exclusive_maximum: None,
      exclusive_minimum: None,
      external_docs: None,
      format: None,
      id: None,
      items: None,
      max_items: None,
      max_length: None,
      max_properties: None,
      maximum: None,
      min_items: None,
      min_length: None,
      min_properties: None,
      minimum: None,
      multiple_of: None,
      not: None,
      one_of: None,
      pattern: None,
      pattern_properties: None,
      properties: None,
      required: None,
      title: None,
      _type: None,
      unique_items: None
    }
  }

  pub fn set__ref(&mut self, _ref: String) {
    self._ref = Some(_ref);
  }

  pub fn with__ref(mut self, _ref: String) -> V1beta1JsonSchemaProps {
    self._ref = Some(_ref);
    self
  }

  pub fn _ref(&self) -> Option<&String> {
    self._ref.as_ref()
  }

  pub fn reset__ref(&mut self) {
    self._ref = None;
  }

  pub fn set_schema(&mut self, schema: String) {
    self.schema = Some(schema);
  }

  pub fn with_schema(mut self, schema: String) -> V1beta1JsonSchemaProps {
    self.schema = Some(schema);
    self
  }

  pub fn schema(&self) -> Option<&String> {
    self.schema.as_ref()
  }

  pub fn reset_schema(&mut self) {
    self.schema = None;
  }

  pub fn set_additional_items(&mut self, additional_items: ::serde_json::Value) {
    self.additional_items = Some(additional_items);
  }

  pub fn with_additional_items(mut self, additional_items: ::serde_json::Value) -> V1beta1JsonSchemaProps {
    self.additional_items = Some(additional_items);
    self
  }

  pub fn additional_items(&self) -> Option<&Value> {
    self.additional_items.as_ref()
  }

  pub fn reset_additional_items(&mut self) {
    self.additional_items = None;
  }

  pub fn set_additional_properties(&mut self, additional_properties: ::serde_json::Value) {
    self.additional_properties = Some(additional_properties);
  }

  pub fn with_additional_properties(mut self, additional_properties: ::serde_json::Value) -> V1beta1JsonSchemaProps {
    self.additional_properties = Some(additional_properties);
    self
  }

  pub fn additional_properties(&self) -> Option<&Value> {
    self.additional_properties.as_ref()
  }

  pub fn reset_additional_properties(&mut self) {
    self.additional_properties = None;
  }

  pub fn set_all_of(&mut self, all_of: Vec<::models::V1beta1JsonSchemaProps>) {
    self.all_of = Some(all_of);
  }

  pub fn with_all_of(mut self, all_of: Vec<::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.all_of = Some(all_of);
    self
  }

  pub fn all_of(&self) -> Option<&Vec<::models::V1beta1JsonSchemaProps>> {
    self.all_of.as_ref()
  }

  pub fn reset_all_of(&mut self) {
    self.all_of = None;
  }

  pub fn set_any_of(&mut self, any_of: Vec<::models::V1beta1JsonSchemaProps>) {
    self.any_of = Some(any_of);
  }

  pub fn with_any_of(mut self, any_of: Vec<::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.any_of = Some(any_of);
    self
  }

  pub fn any_of(&self) -> Option<&Vec<::models::V1beta1JsonSchemaProps>> {
    self.any_of.as_ref()
  }

  pub fn reset_any_of(&mut self) {
    self.any_of = None;
  }

  pub fn set_default(&mut self, default: ::serde_json::Value) {
    self.default = Some(default);
  }

  pub fn with_default(mut self, default: ::serde_json::Value) -> V1beta1JsonSchemaProps {
    self.default = Some(default);
    self
  }

  pub fn default(&self) -> Option<&Value> {
    self.default.as_ref()
  }

  pub fn reset_default(&mut self) {
    self.default = None;
  }

  pub fn set_definitions(&mut self, definitions: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) {
    self.definitions = Some(definitions);
  }

  pub fn with_definitions(mut self, definitions: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.definitions = Some(definitions);
    self
  }

  pub fn definitions(&self) -> Option<&::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>> {
    self.definitions.as_ref()
  }

  pub fn reset_definitions(&mut self) {
    self.definitions = None;
  }

  pub fn set_dependencies(&mut self, dependencies: ::std::collections::HashMap<String, ::serde_json::Value>) {
    self.dependencies = Some(dependencies);
  }

  pub fn with_dependencies(mut self, dependencies: ::std::collections::HashMap<String, ::serde_json::Value>) -> V1beta1JsonSchemaProps {
    self.dependencies = Some(dependencies);
    self
  }

  pub fn dependencies(&self) -> Option<&::std::collections::HashMap<String, ::serde_json::Value>> {
    self.dependencies.as_ref()
  }

  pub fn reset_dependencies(&mut self) {
    self.dependencies = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> V1beta1JsonSchemaProps {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set__enum(&mut self, _enum: Vec<::serde_json::Value>) {
    self._enum = Some(_enum);
  }

  pub fn with__enum(mut self, _enum: Vec<::serde_json::Value>) -> V1beta1JsonSchemaProps {
    self._enum = Some(_enum);
    self
  }

  pub fn _enum(&self) -> Option<&Vec<::serde_json::Value>> {
    self._enum.as_ref()
  }

  pub fn reset__enum(&mut self) {
    self._enum = None;
  }

  pub fn set_example(&mut self, example: ::serde_json::Value) {
    self.example = Some(example);
  }

  pub fn with_example(mut self, example: ::serde_json::Value) -> V1beta1JsonSchemaProps {
    self.example = Some(example);
    self
  }

  pub fn example(&self) -> Option<&Value> {
    self.example.as_ref()
  }

  pub fn reset_example(&mut self) {
    self.example = None;
  }

  pub fn set_exclusive_maximum(&mut self, exclusive_maximum: bool) {
    self.exclusive_maximum = Some(exclusive_maximum);
  }

  pub fn with_exclusive_maximum(mut self, exclusive_maximum: bool) -> V1beta1JsonSchemaProps {
    self.exclusive_maximum = Some(exclusive_maximum);
    self
  }

  pub fn exclusive_maximum(&self) -> Option<&bool> {
    self.exclusive_maximum.as_ref()
  }

  pub fn reset_exclusive_maximum(&mut self) {
    self.exclusive_maximum = None;
  }

  pub fn set_exclusive_minimum(&mut self, exclusive_minimum: bool) {
    self.exclusive_minimum = Some(exclusive_minimum);
  }

  pub fn with_exclusive_minimum(mut self, exclusive_minimum: bool) -> V1beta1JsonSchemaProps {
    self.exclusive_minimum = Some(exclusive_minimum);
    self
  }

  pub fn exclusive_minimum(&self) -> Option<&bool> {
    self.exclusive_minimum.as_ref()
  }

  pub fn reset_exclusive_minimum(&mut self) {
    self.exclusive_minimum = None;
  }

  pub fn set_external_docs(&mut self, external_docs: ::models::V1beta1ExternalDocumentation) {
    self.external_docs = Some(external_docs);
  }

  pub fn with_external_docs(mut self, external_docs: ::models::V1beta1ExternalDocumentation) -> V1beta1JsonSchemaProps {
    self.external_docs = Some(external_docs);
    self
  }

  pub fn external_docs(&self) -> Option<&::models::V1beta1ExternalDocumentation> {
    self.external_docs.as_ref()
  }

  pub fn reset_external_docs(&mut self) {
    self.external_docs = None;
  }

  pub fn set_format(&mut self, format: String) {
    self.format = Some(format);
  }

  pub fn with_format(mut self, format: String) -> V1beta1JsonSchemaProps {
    self.format = Some(format);
    self
  }

  pub fn format(&self) -> Option<&String> {
    self.format.as_ref()
  }

  pub fn reset_format(&mut self) {
    self.format = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> V1beta1JsonSchemaProps {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_items(&mut self, items: ::serde_json::Value) {
    self.items = Some(items);
  }

  pub fn with_items(mut self, items: ::serde_json::Value) -> V1beta1JsonSchemaProps {
    self.items = Some(items);
    self
  }

  pub fn items(&self) -> Option<&Value> {
    self.items.as_ref()
  }

  pub fn reset_items(&mut self) {
    self.items = None;
  }

  pub fn set_max_items(&mut self, max_items: i64) {
    self.max_items = Some(max_items);
  }

  pub fn with_max_items(mut self, max_items: i64) -> V1beta1JsonSchemaProps {
    self.max_items = Some(max_items);
    self
  }

  pub fn max_items(&self) -> Option<&i64> {
    self.max_items.as_ref()
  }

  pub fn reset_max_items(&mut self) {
    self.max_items = None;
  }

  pub fn set_max_length(&mut self, max_length: i64) {
    self.max_length = Some(max_length);
  }

  pub fn with_max_length(mut self, max_length: i64) -> V1beta1JsonSchemaProps {
    self.max_length = Some(max_length);
    self
  }

  pub fn max_length(&self) -> Option<&i64> {
    self.max_length.as_ref()
  }

  pub fn reset_max_length(&mut self) {
    self.max_length = None;
  }

  pub fn set_max_properties(&mut self, max_properties: i64) {
    self.max_properties = Some(max_properties);
  }

  pub fn with_max_properties(mut self, max_properties: i64) -> V1beta1JsonSchemaProps {
    self.max_properties = Some(max_properties);
    self
  }

  pub fn max_properties(&self) -> Option<&i64> {
    self.max_properties.as_ref()
  }

  pub fn reset_max_properties(&mut self) {
    self.max_properties = None;
  }

  pub fn set_maximum(&mut self, maximum: f64) {
    self.maximum = Some(maximum);
  }

  pub fn with_maximum(mut self, maximum: f64) -> V1beta1JsonSchemaProps {
    self.maximum = Some(maximum);
    self
  }

  pub fn maximum(&self) -> Option<&f64> {
    self.maximum.as_ref()
  }

  pub fn reset_maximum(&mut self) {
    self.maximum = None;
  }

  pub fn set_min_items(&mut self, min_items: i64) {
    self.min_items = Some(min_items);
  }

  pub fn with_min_items(mut self, min_items: i64) -> V1beta1JsonSchemaProps {
    self.min_items = Some(min_items);
    self
  }

  pub fn min_items(&self) -> Option<&i64> {
    self.min_items.as_ref()
  }

  pub fn reset_min_items(&mut self) {
    self.min_items = None;
  }

  pub fn set_min_length(&mut self, min_length: i64) {
    self.min_length = Some(min_length);
  }

  pub fn with_min_length(mut self, min_length: i64) -> V1beta1JsonSchemaProps {
    self.min_length = Some(min_length);
    self
  }

  pub fn min_length(&self) -> Option<&i64> {
    self.min_length.as_ref()
  }

  pub fn reset_min_length(&mut self) {
    self.min_length = None;
  }

  pub fn set_min_properties(&mut self, min_properties: i64) {
    self.min_properties = Some(min_properties);
  }

  pub fn with_min_properties(mut self, min_properties: i64) -> V1beta1JsonSchemaProps {
    self.min_properties = Some(min_properties);
    self
  }

  pub fn min_properties(&self) -> Option<&i64> {
    self.min_properties.as_ref()
  }

  pub fn reset_min_properties(&mut self) {
    self.min_properties = None;
  }

  pub fn set_minimum(&mut self, minimum: f64) {
    self.minimum = Some(minimum);
  }

  pub fn with_minimum(mut self, minimum: f64) -> V1beta1JsonSchemaProps {
    self.minimum = Some(minimum);
    self
  }

  pub fn minimum(&self) -> Option<&f64> {
    self.minimum.as_ref()
  }

  pub fn reset_minimum(&mut self) {
    self.minimum = None;
  }

  pub fn set_multiple_of(&mut self, multiple_of: f64) {
    self.multiple_of = Some(multiple_of);
  }

  pub fn with_multiple_of(mut self, multiple_of: f64) -> V1beta1JsonSchemaProps {
    self.multiple_of = Some(multiple_of);
    self
  }

  pub fn multiple_of(&self) -> Option<&f64> {
    self.multiple_of.as_ref()
  }

  pub fn reset_multiple_of(&mut self) {
    self.multiple_of = None;
  }

  pub fn set_not(&mut self, not: Box<::models::V1beta1JsonSchemaProps>) {
    self.not = Some(not);
  }

  pub fn with_not(mut self, not: Box<::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.not = Some(not);
    self
  }

  pub fn not(&self) -> Option<&Box<::models::V1beta1JsonSchemaProps>> {
    self.not.as_ref()
  }

  pub fn reset_not(&mut self) {
    self.not = None;
  }

  pub fn set_one_of(&mut self, one_of: Vec<::models::V1beta1JsonSchemaProps>) {
    self.one_of = Some(one_of);
  }

  pub fn with_one_of(mut self, one_of: Vec<::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.one_of = Some(one_of);
    self
  }

  pub fn one_of(&self) -> Option<&Vec<::models::V1beta1JsonSchemaProps>> {
    self.one_of.as_ref()
  }

  pub fn reset_one_of(&mut self) {
    self.one_of = None;
  }

  pub fn set_pattern(&mut self, pattern: String) {
    self.pattern = Some(pattern);
  }

  pub fn with_pattern(mut self, pattern: String) -> V1beta1JsonSchemaProps {
    self.pattern = Some(pattern);
    self
  }

  pub fn pattern(&self) -> Option<&String> {
    self.pattern.as_ref()
  }

  pub fn reset_pattern(&mut self) {
    self.pattern = None;
  }

  pub fn set_pattern_properties(&mut self, pattern_properties: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) {
    self.pattern_properties = Some(pattern_properties);
  }

  pub fn with_pattern_properties(mut self, pattern_properties: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.pattern_properties = Some(pattern_properties);
    self
  }

  pub fn pattern_properties(&self) -> Option<&::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>> {
    self.pattern_properties.as_ref()
  }

  pub fn reset_pattern_properties(&mut self) {
    self.pattern_properties = None;
  }

  pub fn set_properties(&mut self, properties: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) {
    self.properties = Some(properties);
  }

  pub fn with_properties(mut self, properties: ::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>) -> V1beta1JsonSchemaProps {
    self.properties = Some(properties);
    self
  }

  pub fn properties(&self) -> Option<&::std::collections::HashMap<String, ::models::V1beta1JsonSchemaProps>> {
    self.properties.as_ref()
  }

  pub fn reset_properties(&mut self) {
    self.properties = None;
  }

  pub fn set_required(&mut self, required: Vec<String>) {
    self.required = Some(required);
  }

  pub fn with_required(mut self, required: Vec<String>) -> V1beta1JsonSchemaProps {
    self.required = Some(required);
    self
  }

  pub fn required(&self) -> Option<&Vec<String>> {
    self.required.as_ref()
  }

  pub fn reset_required(&mut self) {
    self.required = None;
  }

  pub fn set_title(&mut self, title: String) {
    self.title = Some(title);
  }

  pub fn with_title(mut self, title: String) -> V1beta1JsonSchemaProps {
    self.title = Some(title);
    self
  }

  pub fn title(&self) -> Option<&String> {
    self.title.as_ref()
  }

  pub fn reset_title(&mut self) {
    self.title = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: String) -> V1beta1JsonSchemaProps {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&String> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

  pub fn set_unique_items(&mut self, unique_items: bool) {
    self.unique_items = Some(unique_items);
  }

  pub fn with_unique_items(mut self, unique_items: bool) -> V1beta1JsonSchemaProps {
    self.unique_items = Some(unique_items);
    self
  }

  pub fn unique_items(&self) -> Option<&bool> {
    self.unique_items.as_ref()
  }

  pub fn reset_unique_items(&mut self) {
    self.unique_items = None;
  }

}



