/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.17
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use super::{Error, configuration};

pub struct CoreV1ApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> CoreV1ApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> CoreV1ApiClient<C> {
        CoreV1ApiClient {
            configuration: configuration,
        }
    }
}

pub trait CoreV1Api {
    fn connect_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_delete_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_get_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_head_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_options_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_post_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn connect_put_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>>;
    fn create_namespace(&self, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn create_namespaced_binding(&self, namespace: &str, body: ::models::V1Binding, pretty: &str) -> Box<Future<Item = ::models::V1Binding, Error = Error>>;
    fn create_namespaced_config_map(&self, namespace: &str, body: ::models::V1ConfigMap, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>>;
    fn create_namespaced_endpoints(&self, namespace: &str, body: ::models::V1Endpoints, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>>;
    fn create_namespaced_event(&self, namespace: &str, body: ::models::V1Event, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>>;
    fn create_namespaced_limit_range(&self, namespace: &str, body: ::models::V1LimitRange, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>>;
    fn create_namespaced_persistent_volume_claim(&self, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn create_namespaced_pod(&self, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn create_namespaced_pod_binding(&self, name: &str, namespace: &str, body: ::models::V1Binding, pretty: &str) -> Box<Future<Item = ::models::V1Binding, Error = Error>>;
    fn create_namespaced_pod_eviction(&self, name: &str, namespace: &str, body: ::models::V1beta1Eviction, pretty: &str) -> Box<Future<Item = ::models::V1beta1Eviction, Error = Error>>;
    fn create_namespaced_pod_template(&self, namespace: &str, body: ::models::V1PodTemplate, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>>;
    fn create_namespaced_replication_controller(&self, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn create_namespaced_resource_quota(&self, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn create_namespaced_secret(&self, namespace: &str, body: ::models::V1Secret, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>>;
    fn create_namespaced_service(&self, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn create_namespaced_service_account(&self, namespace: &str, body: ::models::V1ServiceAccount, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>>;
    fn create_node(&self, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn create_persistent_volume(&self, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn delete_collection_namespaced_config_map(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_endpoints(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_event(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_limit_range(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_pod(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_pod_template(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_replication_controller(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_resource_quota(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_secret(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_namespaced_service_account(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_node(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_collection_persistent_volume(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespace(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_config_map(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_event(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_pod(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_secret(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_service(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_namespaced_service_account(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_node(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn delete_persistent_volume(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>>;
    fn get_api_resources(&self, ) -> Box<Future<Item = ::models::V1ApiResourceList, Error = Error>>;
    fn list_component_status(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ComponentStatusList, Error = Error>>;
    fn list_config_map_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ConfigMapList, Error = Error>>;
    fn list_endpoints_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EndpointsList, Error = Error>>;
    fn list_event_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EventList, Error = Error>>;
    fn list_limit_range_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1LimitRangeList, Error = Error>>;
    fn list_namespace(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1NamespaceList, Error = Error>>;
    fn list_namespaced_config_map(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ConfigMapList, Error = Error>>;
    fn list_namespaced_endpoints(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EndpointsList, Error = Error>>;
    fn list_namespaced_event(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EventList, Error = Error>>;
    fn list_namespaced_limit_range(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1LimitRangeList, Error = Error>>;
    fn list_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaimList, Error = Error>>;
    fn list_namespaced_pod(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodList, Error = Error>>;
    fn list_namespaced_pod_template(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodTemplateList, Error = Error>>;
    fn list_namespaced_replication_controller(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ReplicationControllerList, Error = Error>>;
    fn list_namespaced_resource_quota(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ResourceQuotaList, Error = Error>>;
    fn list_namespaced_secret(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1SecretList, Error = Error>>;
    fn list_namespaced_service(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceList, Error = Error>>;
    fn list_namespaced_service_account(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceAccountList, Error = Error>>;
    fn list_node(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1NodeList, Error = Error>>;
    fn list_persistent_volume(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeList, Error = Error>>;
    fn list_persistent_volume_claim_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaimList, Error = Error>>;
    fn list_pod_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodList, Error = Error>>;
    fn list_pod_template_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodTemplateList, Error = Error>>;
    fn list_replication_controller_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ReplicationControllerList, Error = Error>>;
    fn list_resource_quota_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ResourceQuotaList, Error = Error>>;
    fn list_secret_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1SecretList, Error = Error>>;
    fn list_service_account_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceAccountList, Error = Error>>;
    fn list_service_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceList, Error = Error>>;
    fn patch_namespace(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn patch_namespace_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn patch_namespaced_config_map(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>>;
    fn patch_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>>;
    fn patch_namespaced_event(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>>;
    fn patch_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>>;
    fn patch_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn patch_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn patch_namespaced_pod(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn patch_namespaced_pod_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn patch_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>>;
    fn patch_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn patch_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>>;
    fn patch_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn patch_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn patch_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn patch_namespaced_secret(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>>;
    fn patch_namespaced_service(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn patch_namespaced_service_account(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>>;
    fn patch_namespaced_service_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn patch_node(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn patch_node_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn patch_persistent_volume(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn patch_persistent_volume_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn proxy_delete_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_delete_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_delete_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_delete_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_delete_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_delete_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_get_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_head_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_options_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_patch_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_post_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>>;
    fn proxy_put_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>>;
    fn read_component_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1ComponentStatus, Error = Error>>;
    fn read_namespace(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn read_namespace_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn read_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>>;
    fn read_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>>;
    fn read_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Event, Error = Error>>;
    fn read_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>>;
    fn read_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn read_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn read_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn read_namespaced_pod_log(&self, name: &str, namespace: &str, container: &str, follow: bool, limit_bytes: i32, pretty: &str, previous: bool, since_seconds: i32, tail_lines: i32, timestamps: bool) -> Box<Future<Item = String, Error = Error>>;
    fn read_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn read_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>>;
    fn read_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn read_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>>;
    fn read_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn read_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn read_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn read_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Secret, Error = Error>>;
    fn read_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn read_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>>;
    fn read_namespaced_service_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn read_node(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn read_node_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn read_persistent_volume(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn read_persistent_volume_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn replace_namespace(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn replace_namespace_finalize(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn replace_namespace_status(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>>;
    fn replace_namespaced_config_map(&self, name: &str, namespace: &str, body: ::models::V1ConfigMap, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>>;
    fn replace_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::models::V1Endpoints, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>>;
    fn replace_namespaced_event(&self, name: &str, namespace: &str, body: ::models::V1Event, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>>;
    fn replace_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::models::V1LimitRange, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>>;
    fn replace_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn replace_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>>;
    fn replace_namespaced_pod(&self, name: &str, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn replace_namespaced_pod_status(&self, name: &str, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>>;
    fn replace_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::models::V1PodTemplate, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>>;
    fn replace_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn replace_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: ::models::V1Scale, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>>;
    fn replace_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>>;
    fn replace_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn replace_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>>;
    fn replace_namespaced_secret(&self, name: &str, namespace: &str, body: ::models::V1Secret, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>>;
    fn replace_namespaced_service(&self, name: &str, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn replace_namespaced_service_account(&self, name: &str, namespace: &str, body: ::models::V1ServiceAccount, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>>;
    fn replace_namespaced_service_status(&self, name: &str, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>>;
    fn replace_node(&self, name: &str, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn replace_node_status(&self, name: &str, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>>;
    fn replace_persistent_volume(&self, name: &str, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
    fn replace_persistent_volume_status(&self, name: &str, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>>;
}


impl<C: hyper::client::Connect>CoreV1Api for CoreV1ApiClient<C> {
    fn connect_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_delete_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("container", &container.to_string())
            .append_pair("stderr", &stderr.to_string())
            .append_pair("stdin", &stdin.to_string())
            .append_pair("stdout", &stdout.to_string())
            .append_pair("tty", &tty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/attach{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("command", &command.to_string())
            .append_pair("container", &container.to_string())
            .append_pair("stderr", &stderr.to_string())
            .append_pair("stdin", &stdin.to_string())
            .append_pair("stdout", &stdout.to_string())
            .append_pair("tty", &tty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/exec{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("ports", &ports.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/portforward{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_get_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_head_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_options_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("container", &container.to_string())
            .append_pair("stderr", &stderr.to_string())
            .append_pair("stdin", &stdin.to_string())
            .append_pair("stdout", &stdout.to_string())
            .append_pair("tty", &tty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/attach{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("command", &command.to_string())
            .append_pair("container", &container.to_string())
            .append_pair("stderr", &stderr.to_string())
            .append_pair("stdin", &stdin.to_string())
            .append_pair("stdout", &stdout.to_string())
            .append_pair("tty", &tty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/exec{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("ports", &ports.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/portforward{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_post_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}{}", configuration.base_path, query, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_node_proxy(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn connect_put_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path2.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}{}", configuration.base_path, query, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespace(&self, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_binding(&self, namespace: &str, body: ::models::V1Binding, pretty: &str) -> Box<Future<Item = ::models::V1Binding, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/bindings{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Binding, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_config_map(&self, namespace: &str, body: ::models::V1ConfigMap, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMap, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_endpoints(&self, namespace: &str, body: ::models::V1Endpoints, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Endpoints, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_event(&self, namespace: &str, body: ::models::V1Event, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Event, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_limit_range(&self, namespace: &str, body: ::models::V1LimitRange, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRange, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_persistent_volume_claim(&self, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_pod(&self, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_pod_binding(&self, name: &str, namespace: &str, body: ::models::V1Binding, pretty: &str) -> Box<Future<Item = ::models::V1Binding, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/binding{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Binding, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_pod_eviction(&self, name: &str, namespace: &str, body: ::models::V1beta1Eviction, pretty: &str) -> Box<Future<Item = ::models::V1beta1Eviction, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/eviction{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1beta1Eviction, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_pod_template(&self, namespace: &str, body: ::models::V1PodTemplate, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplate, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_replication_controller(&self, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_resource_quota(&self, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_secret(&self, namespace: &str, body: ::models::V1Secret, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Secret, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_service(&self, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_namespaced_service_account(&self, namespace: &str, body: ::models::V1ServiceAccount, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccount, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_node(&self, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_persistent_volume(&self, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_config_map(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_endpoints(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_event(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_limit_range(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_pod(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_pod_template(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_replication_controller(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_resource_quota(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_secret(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_namespaced_service_account(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_node(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_collection_persistent_volume(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespace(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_config_map(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_event(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_pod(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_secret(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_service(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_namespaced_service_account(&self, name: &str, namespace: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_node(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_persistent_volume(&self, name: &str, body: ::models::V1DeleteOptions, pretty: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str) -> Box<Future<Item = ::models::V1Status, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("gracePeriodSeconds", &grace_period_seconds.to_string())
            .append_pair("orphanDependents", &orphan_dependents.to_string())
            .append_pair("propagationPolicy", &propagation_policy.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Status, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_api_resources(&self, ) -> Box<Future<Item = ::models::V1ApiResourceList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ApiResourceList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_component_status(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ComponentStatusList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/componentstatuses{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ComponentStatusList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_config_map_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ConfigMapList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/configmaps{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMapList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_endpoints_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EndpointsList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/endpoints{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1EndpointsList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_event_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EventList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/events{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1EventList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_limit_range_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1LimitRangeList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/limitranges{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRangeList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespace(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1NamespaceList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1NamespaceList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_config_map(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ConfigMapList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMapList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_endpoints(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EndpointsList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1EndpointsList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_event(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1EventList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1EventList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_limit_range(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1LimitRangeList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRangeList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaimList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaimList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_pod(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_pod_template(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodTemplateList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplateList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_replication_controller(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ReplicationControllerList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationControllerList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_resource_quota(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ResourceQuotaList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuotaList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_secret(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1SecretList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1SecretList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_service(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_namespaced_service_account(&self, namespace: &str, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceAccountList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts{}", configuration.base_path, query, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccountList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_node(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1NodeList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1NodeList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_persistent_volume(&self, pretty: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_persistent_volume_claim_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaimList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumeclaims{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaimList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_pod_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/pods{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_pod_template_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1PodTemplateList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/podtemplates{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplateList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_replication_controller_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ReplicationControllerList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/replicationcontrollers{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationControllerList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_resource_quota_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ResourceQuotaList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/resourcequotas{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuotaList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_secret_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1SecretList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/secrets{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1SecretList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_service_account_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceAccountList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/serviceaccounts{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccountList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_service_for_all_namespaces(&self, field_selector: &str, include_uninitialized: bool, label_selector: &str, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Box<Future<Item = ::models::V1ServiceList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("fieldSelector", &field_selector.to_string())
            .append_pair("includeUninitialized", &include_uninitialized.to_string())
            .append_pair("labelSelector", &label_selector.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("resourceVersion", &resource_version.to_string())
            .append_pair("timeoutSeconds", &timeout_seconds.to_string())
            .append_pair("watch", &watch.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/services{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespace(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespace_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_config_map(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMap, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Endpoints, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_event(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Event, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRange, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_pod(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_pod_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplate, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Scale, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_secret(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Secret, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_service(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_service_account(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccount, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_namespaced_service_status(&self, name: &str, namespace: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_node(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_node_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_persistent_volume(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn patch_persistent_volume_status(&self, name: &str, body: ::serde_json::Value, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_delete_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_get_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_head_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_options_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Options;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_patch_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_post_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_namespaced_pod(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_namespaced_pod_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_namespaced_service(&self, name: &str, namespace: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}", configuration.base_path, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_namespaced_service_with_path(&self, name: &str, namespace: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", configuration.base_path, name=name, namespace=namespace, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_node(&self, name: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}", configuration.base_path, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn proxy_put_node_with_path(&self, name: &str, path: &str) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/api/v1/proxy/nodes/{name}/{path}", configuration.base_path, name=name, path=path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_component_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1ComponentStatus, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/componentstatuses/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ComponentStatus, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespace(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespace_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMap, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Endpoints, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Event, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Event, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRange, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_pod_log(&self, name: &str, namespace: &str, container: &str, follow: bool, limit_bytes: i32, pretty: &str, previous: bool, since_seconds: i32, tail_lines: i32, timestamps: bool) -> Box<Future<Item = String, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("container", &container.to_string())
            .append_pair("follow", &follow.to_string())
            .append_pair("limitBytes", &limit_bytes.to_string())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("previous", &previous.to_string())
            .append_pair("sinceSeconds", &since_seconds.to_string())
            .append_pair("tailLines", &tail_lines.to_string())
            .append_pair("timestamps", &timestamps.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/log{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplate, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Scale, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Secret, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Secret, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccount, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_namespaced_service_status(&self, name: &str, namespace: &str, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_node(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_node_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_persistent_volume(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .append_pair("exact", &exact.to_string())
            .append_pair("export", &export.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn read_persistent_volume_status(&self, name: &str, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespace(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespace_finalize(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}/finalize{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespace_status(&self, name: &str, body: ::models::V1Namespace, pretty: &str) -> Box<Future<Item = ::models::V1Namespace, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Namespace, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_config_map(&self, name: &str, namespace: &str, body: ::models::V1ConfigMap, pretty: &str) -> Box<Future<Item = ::models::V1ConfigMap, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ConfigMap, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_endpoints(&self, name: &str, namespace: &str, body: ::models::V1Endpoints, pretty: &str) -> Box<Future<Item = ::models::V1Endpoints, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Endpoints, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_event(&self, name: &str, namespace: &str, body: ::models::V1Event, pretty: &str) -> Box<Future<Item = ::models::V1Event, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Event, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_limit_range(&self, name: &str, namespace: &str, body: ::models::V1LimitRange, pretty: &str) -> Box<Future<Item = ::models::V1LimitRange, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1LimitRange, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: ::models::V1PersistentVolumeClaim, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolumeClaim, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolumeClaim, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_pod(&self, name: &str, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_pod_status(&self, name: &str, namespace: &str, body: ::models::V1Pod, pretty: &str) -> Box<Future<Item = ::models::V1Pod, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Pod, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_pod_template(&self, name: &str, namespace: &str, body: ::models::V1PodTemplate, pretty: &str) -> Box<Future<Item = ::models::V1PodTemplate, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PodTemplate, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_replication_controller(&self, name: &str, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: ::models::V1Scale, pretty: &str) -> Box<Future<Item = ::models::V1Scale, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Scale, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: ::models::V1ReplicationController, pretty: &str) -> Box<Future<Item = ::models::V1ReplicationController, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ReplicationController, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_resource_quota(&self, name: &str, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: ::models::V1ResourceQuota, pretty: &str) -> Box<Future<Item = ::models::V1ResourceQuota, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ResourceQuota, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_secret(&self, name: &str, namespace: &str, body: ::models::V1Secret, pretty: &str) -> Box<Future<Item = ::models::V1Secret, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Secret, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_service(&self, name: &str, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_service_account(&self, name: &str, namespace: &str, body: ::models::V1ServiceAccount, pretty: &str) -> Box<Future<Item = ::models::V1ServiceAccount, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1ServiceAccount, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_namespaced_service_status(&self, name: &str, namespace: &str, body: ::models::V1Service, pretty: &str) -> Box<Future<Item = ::models::V1Service, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status{}", configuration.base_path, query, name=name, namespace=namespace);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Service, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_node(&self, name: &str, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_node_status(&self, name: &str, body: ::models::V1Node, pretty: &str) -> Box<Future<Item = ::models::V1Node, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/nodes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1Node, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_persistent_volume(&self, name: &str, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn replace_persistent_volume_status(&self, name: &str, body: ::models::V1PersistentVolume, pretty: &str) -> Box<Future<Item = ::models::V1PersistentVolume, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("pretty", &pretty.to_string())
            .finish();
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status{}", configuration.base_path, query, name=name);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::V1PersistentVolume, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

}
