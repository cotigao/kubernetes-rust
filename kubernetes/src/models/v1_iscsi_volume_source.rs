/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.12.3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// V1IscsiVolumeSource : Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct V1IscsiVolumeSource {
  /// whether support iSCSI Discovery CHAP authentication
  #[serde(rename = "chapAuthDiscovery")]
  chap_auth_discovery: Option<bool>,
  /// whether support iSCSI Session CHAP authentication
  #[serde(rename = "chapAuthSession")]
  chap_auth_session: Option<bool>,
  /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  #[serde(rename = "fsType")]
  fs_type: Option<String>,
  /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
  #[serde(rename = "initiatorName")]
  initiator_name: Option<String>,
  /// Target iSCSI Qualified Name.
  #[serde(rename = "iqn")]
  iqn: String,
  /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
  #[serde(rename = "iscsiInterface")]
  iscsi_interface: Option<String>,
  /// iSCSI Target Lun number.
  #[serde(rename = "lun")]
  lun: i32,
  /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
  #[serde(rename = "portals")]
  portals: Option<Vec<String>>,
  /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
  #[serde(rename = "readOnly")]
  read_only: Option<bool>,
  /// CHAP Secret for iSCSI target and initiator authentication
  #[serde(rename = "secretRef")]
  secret_ref: Option<::models::V1LocalObjectReference>,
  /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
  #[serde(rename = "targetPortal")]
  target_portal: String
}

impl V1IscsiVolumeSource {
  /// Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
  pub fn new(iqn: String, lun: i32, target_portal: String) -> V1IscsiVolumeSource {
    V1IscsiVolumeSource {
      chap_auth_discovery: None,
      chap_auth_session: None,
      fs_type: None,
      initiator_name: None,
      iqn: iqn,
      iscsi_interface: None,
      lun: lun,
      portals: None,
      read_only: None,
      secret_ref: None,
      target_portal: target_portal
    }
  }

  pub fn set_chap_auth_discovery(&mut self, chap_auth_discovery: bool) {
    self.chap_auth_discovery = Some(chap_auth_discovery);
  }

  pub fn with_chap_auth_discovery(mut self, chap_auth_discovery: bool) -> V1IscsiVolumeSource {
    self.chap_auth_discovery = Some(chap_auth_discovery);
    self
  }

  pub fn chap_auth_discovery(&self) -> Option<&bool> {
    self.chap_auth_discovery.as_ref()
  }

  pub fn reset_chap_auth_discovery(&mut self) {
    self.chap_auth_discovery = None;
  }

  pub fn set_chap_auth_session(&mut self, chap_auth_session: bool) {
    self.chap_auth_session = Some(chap_auth_session);
  }

  pub fn with_chap_auth_session(mut self, chap_auth_session: bool) -> V1IscsiVolumeSource {
    self.chap_auth_session = Some(chap_auth_session);
    self
  }

  pub fn chap_auth_session(&self) -> Option<&bool> {
    self.chap_auth_session.as_ref()
  }

  pub fn reset_chap_auth_session(&mut self) {
    self.chap_auth_session = None;
  }

  pub fn set_fs_type(&mut self, fs_type: String) {
    self.fs_type = Some(fs_type);
  }

  pub fn with_fs_type(mut self, fs_type: String) -> V1IscsiVolumeSource {
    self.fs_type = Some(fs_type);
    self
  }

  pub fn fs_type(&self) -> Option<&String> {
    self.fs_type.as_ref()
  }

  pub fn reset_fs_type(&mut self) {
    self.fs_type = None;
  }

  pub fn set_initiator_name(&mut self, initiator_name: String) {
    self.initiator_name = Some(initiator_name);
  }

  pub fn with_initiator_name(mut self, initiator_name: String) -> V1IscsiVolumeSource {
    self.initiator_name = Some(initiator_name);
    self
  }

  pub fn initiator_name(&self) -> Option<&String> {
    self.initiator_name.as_ref()
  }

  pub fn reset_initiator_name(&mut self) {
    self.initiator_name = None;
  }

  pub fn set_iqn(&mut self, iqn: String) {
    self.iqn = iqn;
  }

  pub fn with_iqn(mut self, iqn: String) -> V1IscsiVolumeSource {
    self.iqn = iqn;
    self
  }

  pub fn iqn(&self) -> &String {
    &self.iqn
  }


  pub fn set_iscsi_interface(&mut self, iscsi_interface: String) {
    self.iscsi_interface = Some(iscsi_interface);
  }

  pub fn with_iscsi_interface(mut self, iscsi_interface: String) -> V1IscsiVolumeSource {
    self.iscsi_interface = Some(iscsi_interface);
    self
  }

  pub fn iscsi_interface(&self) -> Option<&String> {
    self.iscsi_interface.as_ref()
  }

  pub fn reset_iscsi_interface(&mut self) {
    self.iscsi_interface = None;
  }

  pub fn set_lun(&mut self, lun: i32) {
    self.lun = lun;
  }

  pub fn with_lun(mut self, lun: i32) -> V1IscsiVolumeSource {
    self.lun = lun;
    self
  }

  pub fn lun(&self) -> &i32 {
    &self.lun
  }


  pub fn set_portals(&mut self, portals: Vec<String>) {
    self.portals = Some(portals);
  }

  pub fn with_portals(mut self, portals: Vec<String>) -> V1IscsiVolumeSource {
    self.portals = Some(portals);
    self
  }

  pub fn portals(&self) -> Option<&Vec<String>> {
    self.portals.as_ref()
  }

  pub fn reset_portals(&mut self) {
    self.portals = None;
  }

  pub fn set_read_only(&mut self, read_only: bool) {
    self.read_only = Some(read_only);
  }

  pub fn with_read_only(mut self, read_only: bool) -> V1IscsiVolumeSource {
    self.read_only = Some(read_only);
    self
  }

  pub fn read_only(&self) -> Option<&bool> {
    self.read_only.as_ref()
  }

  pub fn reset_read_only(&mut self) {
    self.read_only = None;
  }

  pub fn set_secret_ref(&mut self, secret_ref: ::models::V1LocalObjectReference) {
    self.secret_ref = Some(secret_ref);
  }

  pub fn with_secret_ref(mut self, secret_ref: ::models::V1LocalObjectReference) -> V1IscsiVolumeSource {
    self.secret_ref = Some(secret_ref);
    self
  }

  pub fn secret_ref(&self) -> Option<&::models::V1LocalObjectReference> {
    self.secret_ref.as_ref()
  }

  pub fn reset_secret_ref(&mut self) {
    self.secret_ref = None;
  }

  pub fn set_target_portal(&mut self, target_portal: String) {
    self.target_portal = target_portal;
  }

  pub fn with_target_portal(mut self, target_portal: String) -> V1IscsiVolumeSource {
    self.target_portal = target_portal;
    self
  }

  pub fn target_portal(&self) -> &String {
    &self.target_portal
  }


}



