/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.12.3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// V1beta1VolumeAttachmentStatus : VolumeAttachmentStatus is the status of a VolumeAttachment request.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct V1beta1VolumeAttachmentStatus {
  /// The last error encountered during attach operation, if any. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.
  #[serde(rename = "attachError")]
  attach_error: Option<::models::V1beta1VolumeError>,
  /// Indicates the volume is successfully attached. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.
  #[serde(rename = "attached")]
  attached: bool,
  /// Upon successful attach, this field is populated with any information returned by the attach operation that must be passed into subsequent WaitForAttach or Mount calls. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.
  #[serde(rename = "attachmentMetadata")]
  attachment_metadata: Option<::std::collections::HashMap<String, String>>,
  /// The last error encountered during detach operation, if any. This field must only be set by the entity completing the detach operation, i.e. the external-attacher.
  #[serde(rename = "detachError")]
  detach_error: Option<::models::V1beta1VolumeError>
}

impl V1beta1VolumeAttachmentStatus {
  /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
  pub fn new(attached: bool) -> V1beta1VolumeAttachmentStatus {
    V1beta1VolumeAttachmentStatus {
      attach_error: None,
      attached: attached,
      attachment_metadata: None,
      detach_error: None
    }
  }

  pub fn set_attach_error(&mut self, attach_error: ::models::V1beta1VolumeError) {
    self.attach_error = Some(attach_error);
  }

  pub fn with_attach_error(mut self, attach_error: ::models::V1beta1VolumeError) -> V1beta1VolumeAttachmentStatus {
    self.attach_error = Some(attach_error);
    self
  }

  pub fn attach_error(&self) -> Option<&::models::V1beta1VolumeError> {
    self.attach_error.as_ref()
  }

  pub fn reset_attach_error(&mut self) {
    self.attach_error = None;
  }

  pub fn set_attached(&mut self, attached: bool) {
    self.attached = attached;
  }

  pub fn with_attached(mut self, attached: bool) -> V1beta1VolumeAttachmentStatus {
    self.attached = attached;
    self
  }

  pub fn attached(&self) -> &bool {
    &self.attached
  }


  pub fn set_attachment_metadata(&mut self, attachment_metadata: ::std::collections::HashMap<String, String>) {
    self.attachment_metadata = Some(attachment_metadata);
  }

  pub fn with_attachment_metadata(mut self, attachment_metadata: ::std::collections::HashMap<String, String>) -> V1beta1VolumeAttachmentStatus {
    self.attachment_metadata = Some(attachment_metadata);
    self
  }

  pub fn attachment_metadata(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.attachment_metadata.as_ref()
  }

  pub fn reset_attachment_metadata(&mut self) {
    self.attachment_metadata = None;
  }

  pub fn set_detach_error(&mut self, detach_error: ::models::V1beta1VolumeError) {
    self.detach_error = Some(detach_error);
  }

  pub fn with_detach_error(mut self, detach_error: ::models::V1beta1VolumeError) -> V1beta1VolumeAttachmentStatus {
    self.detach_error = Some(detach_error);
    self
  }

  pub fn detach_error(&self) -> Option<&::models::V1beta1VolumeError> {
    self.detach_error.as_ref()
  }

  pub fn reset_detach_error(&mut self) {
    self.detach_error = None;
  }

}



