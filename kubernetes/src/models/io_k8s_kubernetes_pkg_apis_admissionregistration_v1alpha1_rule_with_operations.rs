/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations : RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
  /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.
  #[serde(rename = "apiGroups")]
  api_groups: Option<Vec<String>>,
  /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required.
  #[serde(rename = "apiVersions")]
  api_versions: Option<Vec<String>>,
  /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for all operations. If '*' is present, the length of the slice must be one. Required.
  #[serde(rename = "operations")]
  operations: Option<Vec<String>>,
  /// Resources is a list of resources this rule applies to.  For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/_*' means all subresources of pods. '*_/scale' means all scale subresources. '*_/_*' means all resources and their subresources.  If wildcard is present, the validation rule will ensure resources do not overlap with each other.  Depending on the enclosing object, subresources might not be allowed. Required.
  #[serde(rename = "resources")]
  resources: Option<Vec<String>>
}

impl IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
  /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid.
  pub fn new() -> IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
    IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
      api_groups: None,
      api_versions: None,
      operations: None,
      resources: None
    }
  }

  pub fn set_api_groups(&mut self, api_groups: Vec<String>) {
    self.api_groups = Some(api_groups);
  }

  pub fn with_api_groups(mut self, api_groups: Vec<String>) -> IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
    self.api_groups = Some(api_groups);
    self
  }

  pub fn api_groups(&self) -> Option<&Vec<String>> {
    self.api_groups.as_ref()
  }

  pub fn reset_api_groups(&mut self) {
    self.api_groups = None;
  }

  pub fn set_api_versions(&mut self, api_versions: Vec<String>) {
    self.api_versions = Some(api_versions);
  }

  pub fn with_api_versions(mut self, api_versions: Vec<String>) -> IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
    self.api_versions = Some(api_versions);
    self
  }

  pub fn api_versions(&self) -> Option<&Vec<String>> {
    self.api_versions.as_ref()
  }

  pub fn reset_api_versions(&mut self) {
    self.api_versions = None;
  }

  pub fn set_operations(&mut self, operations: Vec<String>) {
    self.operations = Some(operations);
  }

  pub fn with_operations(mut self, operations: Vec<String>) -> IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
    self.operations = Some(operations);
    self
  }

  pub fn operations(&self) -> Option<&Vec<String>> {
    self.operations.as_ref()
  }

  pub fn reset_operations(&mut self) {
    self.operations = None;
  }

  pub fn set_resources(&mut self, resources: Vec<String>) {
    self.resources = Some(resources);
  }

  pub fn with_resources(mut self, resources: Vec<String>) -> IoK8sKubernetesPkgApisAdmissionregistrationV1alpha1RuleWithOperations {
    self.resources = Some(resources);
    self
  }

  pub fn resources(&self) -> Option<&Vec<String>> {
    self.resources.as_ref()
  }

  pub fn reset_resources(&mut self) {
    self.resources = None;
  }

}



